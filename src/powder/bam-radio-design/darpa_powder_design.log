This profile allows the allocation of resources for over-the-air operation on the POWDER platform. Specifically, the profile has options to request the allocation of SDR radios in rooftop base-stations.

Map of deployment is here: https://www.powderwireless.net/map

This profile works with the CBRS band (3400 - 3800 MHz) NI/Ettus X310 base-station radios in POWDER. The naming scheme for these radios is cbrssdr1-<location>, where 'location' is one of the rooftop names shown in the above map. Each X310 is paired with a compute node (by default a Dell d740).

The instructions below shows how GNU Radio software can be used with SDRs connected to the CBRS antennas to transmit and receive a file with QPSK over OFDM.

Good node pair options to use for this are:

Behavioral and Browning
Behavioral and USTAR
A full set of test results to help in picking devices is located here:

https://docs.google.com/spreadsheets/d/e/2PACX-1vS95aVITSZnZ2gPk4aMnNLrtbV8QgY4_HP93njVN8UcOz5fFLNAadiBp72BcD_epV-WfJWUY9sWpQ2U/pubhtml

Overview
We will use one of the nodes in your experiment as the transmitter and the other as the receiver.

SSH to the nodes
Once the profile is instantiated, go to List View option to get the node address.
With a remote SSH client login to the nodes. (Must have SSH public key uploaded).
While using SSH, make sure the X11 forwarding option is enable (-Y option).
On the transmitter node: Open and edit flowgraph in GNU Radio Companion
GNU Radio provides the building blocks for OFDM modulated signal. We will use these blocks for this experiment.

Open transmitter file
bash -l
gnuradio-companion /local/repository/gnuradio/TX.grc
(Optional) Save the file in your user directory: /users/<username>/ if you'd like to edit it.
The transmitter is now ready to transmit with default configuration.
Note: You may also simply use /local/repository/gnuradio/OFDM_TX.py if you'd rather not start up gnuradio-companion.

Brief description of the transmitter blocks
File Source : Contains the file we want to transmit (image/text/..) Now we have streams of bytes as output without any boundary that defines the start/end of the packet.

Stream to tagged stream : Is the block that defines the packet boundary. It converts a regular stream to tagged stream. All this block does is add a length tag 'packet_len' with a value 30 (or as you provide). Which means after every 30 items there will be a tag called 'packet_len'.

Stream CRC32 : The first byte of the packet has a tag 'packet_len' with value 30 which means the number of bytes in the packet. The output is the same as input with a trailing CRC32 (4 bytes) of the packet. The tag is also now reset to the new length. This is now the payload that we want to transmit. At this step the flow splits up. The top path is for header generator and the bottom is the payload itself.

Protocol Formatter : Takes in the tagged stream packet and creates a header. This is configurable. In flowgraph, the format object points to an object 'hdr_format' that we pass to the block. So the block has the conceptual idea on what it does but how it is done is implemented somewhere else. So its something that we do in python code. We generate a OFDM packet header, giving some information on what I want to do. So the right side, it calculates & generates the header and outputs it on this channel. The other channel is used to transport the payload.

Repack bits : Prepares for modulation (8 bits to 1 bit) for BPSK and (8 bits to 2 bits) for QPSK.

Virtual Sink : When paired with a Virtual Source block, this is essentially the same as drawing a wire between two blocks. This block can be useful for tidying up a complex flowgraph.
Chunks to symbols : Maps bits to complex symbols. Both the paths can have different modulation scheme. Here we have done BPSK for header and QPSK for payload. After this we have complex symbols.
Tagged Stream MUX : Multiplexer : Which still understand packet boundaries. Packets are output sequentially from each input stream. As the input might have different length. The output signal has a new length tag which is the sum of all individual length tags.

OFDM Carrier allocator : Allocates the sub-carriers/pilot carriers that will be occupied by data or pilot symbols. Add sync words.

IFFT : Converts frequency into time domain.
OFDM cyclic Prefixer : Adds guard interval.
Multiply constant : reduces the amplitude so that it is within [-1 : +1] range to avoid clipping.
USRP Sink : Connects to the antenna
Receiver node: Open and edit flowgraph in GNU Radio Companion
Open receiver file
bash -l
gnuradio-companion /local/repository/gnuradio/RX.grc
(Optional) Save the file in /users/<username>/ if you'd like to edit it.

The receiver is now ready to receive and decode the message sent by the transmitter via OFDM (into /tmp/rx.txt).

Note: You may also simply use /local/repository/gnuradio/OFDM_RX.py if you'd rather not start up gnuradio-companion.

Brief description of the receciver blocks
USRP Source : Connects to the receiver antenna. Outputs complex samples to process.

Schmidl & Cox OFDM synchronization : Used for timing synchronization to detect the start of the packet and frequency offset correction with the preambles (sync words).

Header/Payload Demux : Demultilexes the header and payload. It takes in the received signal in the incoming port and drops until a trigger (high signal- non zero, Schmidl & Cox OFDM synchronization finds out the position for packet start) value is received. Once it is triggered the sample are passed to the outgoing port 0. As the length of the header is always knwon/fixed it pipes in the fixed number of header into the first sub-flow to demodulate the header. Once the header is demodulated it feeds back the payload information (eg. length of the payload) so that the payload can be demodulated in the second sub-flow.

FFT : Convert time to frequency domain.

OFDM Channel Estimation : Calculates channel state with sync words.

OFDM Frame Equalizer : Reverses the effect of channel on the received symbol.

OFDM Serializer : Inverse block of carrier allocator. It discard the pilot symbols and output the data symbols.

Constellation Decoder : Decodes constillation points into bits.

Packet Header Parser : Inverse of packet header generator in transmitter. It posts header metadata as a message to the Header Payload demux block.

Execute the flowgraph
Execute the receiver file first by clicking Execute/F6 button on the toolbar.
Execute the transmiter file.
The signal can be viewed in Time/Frequency domain if QT GUI blocks are added after USRP Source at receiver.
Hit Kill button or F7 to stop the transmitter/receiver flow after few seconds.
Open a new terminal for the receive node and open the the received file.
vim /users/username/rx.txt
Basic Parameters that you can modify to check performance: Gain (Tx/Rx), Sampling rate, Bandwidth
Calculate Packet Error Rate
The Packet header parser outputs the metadata of the header. We can use a Message Debug block to save the output to a file on the receiver.

Open your copy of RX.grc with gnuradio-companion (if it isn't already open).
Use the search option in the toolbar to find Message debug block from the right tree panel.
Drag and drop the corresponding block in the working panel.
Connect the ouput port of 'Packet Header' parser block to the print port of 'Message Debug' block.
Click on Generate the flow graph button on the toolbar to save the flow as a python script.
Run the python script generated from the .grc file in receiver. Direct the output to be saved in a text file.
python /path/to/your/OFDM_TX_RX_1.py >> header.txt
Execute the transmitter (as described previously)

Make a copy of the python script PER.py to whereever your header.txt file is located.

cp /proj/mww2019/gnuradio-ofdm-example/PER.py /path/to/header/file/..
Run python script to calculate PER

python3 PER.py

Compute node type

Type of compute node to be paired with the X310 Radios
(default value: d740)

Frequency ranges for over-the-air operation.
(multiValue Group: True)

Frequency Min

Values are rounded to the nearest kilohertz.
(default value: 3550)

Frequency Max

Values are rounded to the nearest kilohertz.
(default value: 3560)

X310 CBRS Radios

Rooftop base-station X310 #1

(default value: cbrssdr1-bes)

Rooftop base-station X310 #2

(default value: cbrssdr1-browning)